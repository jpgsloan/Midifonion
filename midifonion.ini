# CONTROLLER 1:
#  B1.1: [play]
#  B1.2: [reset]
#  B1.3: [midi reset]
#  B1.4: [preset mode]

# CONTROLLER 2:
#  B2.1: [tuning]
#  B2.2: [bypass]
#  B2.3: [live mode]
#  B2.4: [mute]

[p2b8]
[p2b8]
[p2b8]
[p2b8]

# -------------------------------------------------
# Startup
# -------------------------------------------------

[once]
    delay = 0
    trigger = _START_UP_TRIG

[gatetool]
    inputtrigger = _START_UP_TRIG
    gatelength = 2
    outputgate = _STARTING_UP

[copy]
    input = _STARTING_UP * -1 + 1
    output = _STARTING_UP_INV

# -------------------------------------------------
# Main Buttons
# -------------------------------------------------

# [buttongroup]
#   button1 = B2.1
#   button2 = B2.3
#   led1 = L2.1
#   led2 = L2.3
#   buttonoutput1 = _TUNING_MODE
#   buttonoutput2 = _LIVE_MODE

[button]
    button = B2.1
    led = L2.1
    output = _TUNING_MODE

[button]
    select = _SEL_1
    button = B2.2
    led = L2.2
    output = _BYPASS_1

[button]
    select = _SEL_2
    button = B2.2
    led = L2.2
    output = _BYPASS_2

# [button]
#   button = B2.2
#   led = L2.2
#   output = _BYPASS_3

# [button]
#   button = B2.2
#   led = L2.2
#   output = _BYPASS_4

# [button]
#   button = B2.2
#   led = L2.2
#   output = _BYPASS_5

# [button]
#   button = B2.2
#   led = L2.2
#   output = _BYPASS_6

# [button]
#   button = B2.2
#   led = L2.2
#   output = _BYPASS_7

# [button]
#   button = B2.2
#   led = L2.2
#   output = _BYPASS_8

# -------------------------------------------------
# Inputs
# -------------------------------------------------

# CHANNEL 1
# ///////////////////////////////////////
# [copy]

[midiin]
    channel = 1
    usb = 0
    pitch1 = _CH_1_MIDI_IN_1
#   gate1 = _CH_1_MIDI_GATE_1

[copy]
    input = _CH_1_MIDI_IN_1
    output = N1

[copy]
    input = I1
    output = _CH_1_INPUT_1

# CHANNEL 2
# ///////////////////////////////////////
# [copy]

[midiin]
    channel = 2
    usb = 0
    pitch1 = _CH_2_MIDI_IN_1
#   gate1 = _CH_1_MIDI_GATE_1

[copy]
    input = _CH_2_MIDI_IN_1
    output = N2

[copy]
    input = I2
    output = _CH_2_INPUT_1

# -------------------------------------------------
# Outputs
# -------------------------------------------------

# CHANNEL 1
# [copy]

[copy]
    input = _CH_1_OUTPUT_1
    output = O1

[copy]
    input = _CH_1_GATE_1
    output = G1.1

[midiout]
    channel = 1
    pitch1 = _CH_1_OUTPUT_1
    gate1 = _CH_1_GATE_1
    usb = 1
    trs = 1

# CHANNEL 2
# [copy]

[copy]
    input = _CH_2_OUTPUT_1
    output = O2

[copy]
    input = _CH_2_GATE_1
    output = G1.2

[midiout]
    channel = 2
    pitch1 = _CH_2_OUTPUT_1
    gate1 = _CH_2_GATE_1
    usb = 1
    trs = 1

# -------------------------------------------------
# Button Keyboards
# -------------------------------------------------

[buttongroup]
    select = _SEL_1
    maxactive = 13
    button1 = B1.7
    button2 = B1.6
    button3 = B1.8
    button4 = B2.5
    button5 = B2.7
    button6 = B2.8
    button7 = B3.5
    button8 = B3.7
    button9 = B3.6
    button10 = B3.8
    button11 = B4.5
    button12 = B4.7
    button13 = B4.8
    led1 = L1.7
    led2 = L1.6
    led3 = L1.8
    led4 = L2.5
    led5 = L2.7
    led6 = L2.8
    led7 = L3.5
    led8 = L3.7
    led9 = L3.6
    led10 = L3.8
    led11 = L4.5
    led12 = L4.7
    led13 = L4.8
    buttonoutput1 = _C_1
    buttonoutput2 = _C_SH_1
    buttonoutput3 = _D_1
    buttonoutput4 = _D_SH_1
    buttonoutput5 = _E_1
    buttonoutput6 = _F_1
    buttonoutput7 = _F_SH_1
    buttonoutput8 = _G_1
    buttonoutput9 = _G_SH_1
    buttonoutput10 = _A_1
    buttonoutput11 = _A_SH_1
    buttonoutput12 = _B_1
    buttonoutput13 = _C_OCT_1

[minifonion]
    input = _CH_1_INPUT_FOLDED_1
    bypass = _BYPASS_1
    tuningmode = _TUNING_MODE
    select1 = _C_1 + _C_OCT_1
    select3 = _E_1
    select5 = _G_1
    select7 = _B_1
    select9 = _D_1
    select11 = _F_1
    select13 = _A_1
    selectfill1 = _C_SH_1
    selectfill2 = _D_SH_1
    selectfill3 = _F_SH_1
    selectfill4 = _G_SH_1
    selectfill5 = _A_SH_1
    notechange = _CH_1_GATE_1
    output = _CH_1_OUTPUT_1

[pot]
    pot = P1.1
    select = _SEL_1
    outputscale = 0.5
    bipolar = _CH_1_FOLD_MIN

[pot]
    pot = P2.1
    select = _SEL_1
    discrete = 10
    output = _CH_1_FOLD_MAX_OFFSET

[copy]
    input = _CH_1_FOLD_MAX_OFFSET / 10 + 1V
    output = _CH_1_FOLD_MAX

[fold]
    input = _CH_1_INPUT_1
    foldby = 1V
    minimum = _CH_1_FOLD_MIN
    maximum = _CH_1_FOLD_MIN + _CH_1_FOLD_MAX
    output = _CH_1_INPUT_FOLDED_1

[buttongroup]
    select = _SEL_2
    maxactive = 13
    button1 = B1.7
    button2 = B1.6
    button3 = B1.8
    button4 = B2.5
    button5 = B2.7
    button6 = B2.8
    button7 = B3.5
    button8 = B3.7
    button9 = B3.6
    button10 = B3.8
    button11 = B4.5
    button12 = B4.7
    button13 = B4.8
    led1 = L1.7
    led2 = L1.6
    led3 = L1.8
    led4 = L2.5
    led5 = L2.7
    led6 = L2.8
    led7 = L3.5
    led8 = L3.7
    led9 = L3.6
    led10 = L3.8
    led11 = L4.5
    led12 = L4.7
    led13 = L4.8
    buttonoutput1 = _C_2
    buttonoutput2 = _C_SH_2
    buttonoutput3 = _D_2
    buttonoutput4 = _D_SH_2
    buttonoutput5 = _E_2
    buttonoutput6 = _F_2
    buttonoutput7 = _F_SH_2
    buttonoutput8 = _G_2
    buttonoutput9 = _G_SH_2
    buttonoutput10 = _A_2
    buttonoutput11 = _A_SH_2
    buttonoutput12 = _B_2
    buttonoutput13 = _C_OCT_2

[minifonion]
    input = _CH_2_INPUT_FOLDED_1
    bypass = _BYPASS_2
    tuningmode = _TUNING_MODE
    select1 = _C_2 + _C_OCT_2
    select3 = _E_2
    select5 = _G_2
    select7 = _B_2
    select9 = _D_2
    select11 = _F_2
    select13 = _A_2
    selectfill1 = _C_SH_2
    selectfill2 = _D_SH_2
    selectfill3 = _F_SH_2
    selectfill4 = _G_SH_2
    selectfill5 = _A_SH_2
    notechange = _CH_2_GATE_1
    output = _CH_2_OUTPUT_1

[pot]
    pot = P1.1
    select = _SEL_2
    outputscale = 0.5
    bipolar = _CH_2_FOLD_MIN

[pot]
    pot = P2.1
    select = _SEL_2
    discrete = 10
    output = _CH_2_FOLD_MAX_OFFSET

[copy]
    input = _CH_2_FOLD_MAX_OFFSET / 10 + 1V
    output = _CH_2_FOLD_MAX

[fold]
    input = _CH_2_INPUT_1
    foldby = 1V
    minimum = _CH_2_FOLD_MIN
    maximum = _CH_2_FOLD_MIN + _CH_2_FOLD_MAX
    output = _CH_2_INPUT_FOLDED_1

# -------------------------------------------------
# Selector
# -------------------------------------------------

# Detect double clicks on any of the selector buttons, to select all channels.
# Every time a selector is pressed, we store the channel number to the queue.
# And also we trigger a trigger delay (using burst) for ~0.3 seconds from now. If the same button
# is pressed twice during that 0.3 seconds then output 1 and 2 of the queue will
# be equal values, and therefore we've detected a double click. After the 0.3 second
# trigger delay, the delay will push a value of zero (which no other button has been assigned that value)
# to the queue, so that we are guaranteed that the next press will not be duplicate value
# and falsely detect a double click.
[burst]
    hz = 3
    trigger = _CH_BUTTON_PRESSED
    skip = 1
    output = _ADD_ZERO

[compare]
    input = _ADD_ZERO
    compare = 1
    ifequal = 0
    else = _BTN_NUM
    output = _BTN_NUM_TO_QUEUE

[queue]
    input = _BTN_NUM_TO_QUEUE
    clock = _CH_BUTTON_PRESSED + _ADD_ZERO
    output1 = _LAST_BTN_PRS
    output2 = _LAST_LAST_BTN_PRS

[compare]
    input = _LAST_BTN_PRS
    compare = _LAST_LAST_BTN_PRS
    ifequal = 1
    else = 0
    output = _WAS_DBL_PRS

[copy]
    input = _CH_BUTTON_PRESSED * _WAS_DBL_PRS
    output = _DBL_CLKD_1

# Enforce that the buttons are reset prior to calling out a double click, so that when dbl click activates it will select everything.
[triggerdelay]
    input = _DBL_CLKD_1
    delay = 0.005
    repeats = 1
    output = _DBL_CLKD

# These are the selector buttons themselves. Everytime a selector is pressed,
# and there is only one button being held down, then we reset all the button values to
# the current B registers. This is because only the button you are currently holding
# will have a B register == 1, all others will be 0, and so your selection will end up
# being only the button you are currently pressing. If you are then holding a second button
# with the first still held, it will not trigger the button resets, and therefor let you select
# more channels.
[button]
    button = B3.1 + _DBL_CLKD
    startvalue = B3.1
    clear = _RST_CH_BTNS
    led = L3.1
    output = _SELECT_RAW_1

[button]
    button = B3.2 + _DBL_CLKD
    startvalue = B3.2
    clear = _RST_CH_BTNS
    led = L3.2
    output = _SELECT_RAW_2

[button]
    button = B4.1 + _DBL_CLKD
    startvalue = B4.1
    clear = _RST_CH_BTNS
    led = L4.1
    output = _SELECT_RAW_3

[button]
    button = B4.2 + _DBL_CLKD
    startvalue = B4.2
    clear = _RST_CH_BTNS
    led = L4.2
    output = _SELECT_RAW_4

[button]
    button = B3.3 + _DBL_CLKD
    startvalue = B3.3
    clear = _RST_CH_BTNS
    led = L3.3
    output = _SELECT_RAW_5

[button]
    button = B3.4 + _DBL_CLKD
    startvalue = B3.4
    clear = _RST_CH_BTNS
    led = L3.4
    output = _SELECT_RAW_6

[button]
    button = B4.3 + _DBL_CLKD
    startvalue = B4.3
    clear = _RST_CH_BTNS
    led = L4.3
    output = _SELECT_RAW_7

[button]
    button = B4.4 + _DBL_CLKD
    startvalue = B4.4
    clear = _RST_CH_BTNS
    led = L4.4
    output = _SELECT_RAW_8

[superjust]
    bypass = 1
    input1 = _SELECT_RAW_1 * _STARTING_UP_INV
    input2 = _SELECT_RAW_2 * _STARTING_UP_INV
    input3 = _SELECT_RAW_3 * _STARTING_UP_INV
    input4 = _SELECT_RAW_4 * _STARTING_UP_INV
    input5 = _SELECT_RAW_5 * _STARTING_UP_INV
    input6 = _SELECT_RAW_6 * _STARTING_UP_INV
    input7 = _SELECT_RAW_7 * _STARTING_UP_INV
    input8 = _SELECT_RAW_8 * _STARTING_UP_INV
    output1 = _SEL_1
    output2 = _SEL_2
#   output3 = _SEL_3
#   output4 = _SEL_4
#   output5 = _SEL_5
#   output6 = _SEL_6
#   output7 = _SEL_7
#   output8 = _SEL_8

# Calculate a few important stats, like:
# - Which button is being held down
# - The number of channels selected
# - The number of buttons being actively held down, (this is different from the number of selected channels)
# - A gate whenever any button is pressed
[mixer]
    input1 = B3.1 * 1 + 1
    input2 = B3.2 * 2 + 1
    input3 = B4.1 * 3 + 1
    input4 = B4.2 * 4 + 1
    input5 = B3.3 * 5 + 1
    input6 = B3.4 * 6 + 1
    input7 = B4.3 * 7 + 1
    input8 = B4.4 * 8 + 1
    maximum = _BTN_NUM

# [mixer]
#   input1 = _SEL_1
#   input2 = _SEL_2
#   input3 = _SEL_3
#   input4 = _SEL_4
#   input5 = _SEL_5
#   input6 = _SEL_6
#   input7 = _SEL_7
#   input8 = _SEL_8
#   output = _NUM_SELECTIONS

[mixer]
    input1 = B3.1
    input2 = B3.2
    input3 = B4.1
    input4 = B4.2
    input5 = B3.3
    input6 = B3.4
    input7 = B4.3
    input8 = B4.4
    output = _NUM_BUTTONS_PRESSED
    maximum = _SEL_BTN_PRSSD

# Convert this gate into a trigger
[burst]
    hz = 10
    trigger = _SEL_BTN_PRSSD
    output = _CH_BUTTON_PRESSED

[copy]
    input = _SEL_BTN_PRSSD * -1 + 1
#   output = _SEL_BTN_PRSSD_INV

# only send a reset trigger IF there is only one button being pressed
[compare]
    input = _NUM_BUTTONS_PRESSED
    compare = 1
    ifgreater = 0
    else = 1
    output = _SHOULD_RST_CH_BTNS

[copy]
    input = _CH_BUTTON_PRESSED * _SHOULD_RST_CH_BTNS
    output = _RST_CH_BTNS

# -------------------------------------------------
# keyboard background leds
# -------------------------------------------------

[superjust]
    input1 = L1.7 + 0.2
    input2 = L1.6 + 0.2
    input3 = L1.8 + 0.2
    input4 = L2.5 + 0.2
    input5 = L2.7 + 0.2
    input6 = L2.8 + 0.2
    input7 = L3.5 + 0.2
    input8 = L3.7 + 0.2
    bypass = 1
    output1 = L1.7
    output2 = L1.6
    output3 = L1.8
    output4 = L2.5
    output5 = L2.7
    output6 = L2.8
    output7 = L3.5
    output8 = L3.7

[superjust]
    input1 = L3.6 + 0.2
    input2 = L3.8 + 0.2
    input3 = L4.5 + 0.2
    input4 = L4.7 + 0.2
    input5 = L4.8 + 0.2
    bypass = 1
    output1 = L3.6
    output2 = L3.8
    output3 = L4.5
    output4 = L4.7
    output5 = L4.8
